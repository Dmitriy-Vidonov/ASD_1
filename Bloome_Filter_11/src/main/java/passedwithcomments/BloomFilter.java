package passedwithcomments;

public class BloomFilter
{
    public int filter_len; // длина битового массива
    public int bitStorage; // битовый массив - число типа int
    private boolean isEmpty; // флажок - пустой массив или нет

    public BloomFilter(int f_len)
    {
        filter_len = f_len;
        bitStorage = 0; // 0 - означает обнуление всего битового массива
        isEmpty = true;
    }

    public int hash1(String str1)
    {
        long res = 0; // тип long использован для того, чтобы снизить вероятность операций с минусовым res
        int rand = 17; // рандомное число согласно заданию
        long len = str1.length(); // вызов функции с получением длины строки делаем всего один раз

        for(int i=0; i<len; i++)
        {
            if (i == 0) continue; // принимаем, что результат первой итерации равен нулю, согласно заданию
            int code = str1.charAt(i); // получаем порядковый номер символа из строки
            res += (res * rand) + code; // обновляем переменную res
        }
        return ((res > 0) ? (int)(res % len) : -(int)(res % len)); // если res > 0, то обыйчный %, иначе меняем знак
    }

    public int hash2(String str1) // все аналогично первой хэш-функции, но с другим rand
    {
        long res = 0;
        int rand = 223;
        long len = str1.length();

        for(int i=0; i<len; i++)
        {
            if (i == 0) continue;
            int code = str1.charAt(i);
            res += (res * rand) + code;
        }
        return ((res > 0) ? (int)(res % len) : -(int)(res % len));
    }

    public void add(String str1)
    {
        if(str1.length() == 0) // проверка на случай попытки добавления пустой строки
            return;

        int index1 = hash1(str1); // первый индекс для элемента в битовом массиве
        int index2 = hash2(str1); // второй индекс для элемента в битовом массиве

        this.bitStorage = this.setBit(bitStorage, index1); // добавляем 1 в нужный индекс массива
        this.bitStorage = this.setBit(bitStorage, index2);

        isEmpty = false; // говорим, что теперь массив не пустой
    }

    public boolean isValue(String str1)
    {
        if(str1.length() == 0 || isEmpty) // если длина строки нулевая или массив пуст, то false
            return false;

        int index1 = hash1(str1); // получаем два индекса для искомой строки
        int index2 = hash2(str1);
        // смотрим, чтобы в обеих индексах были единицы, в таком случае проверка элемента положительна
        return (getBit(this.bitStorage, index1) == 1 && getBit(this.bitStorage, index2) == 1);
    }

    public int setBit(int bitStorage, int bitIndex) // установка бита в определенный индекс массива
    {
        int res = bitStorage;
        res |= (1<<bitIndex); // битовый сдвиг
        return res;
    }

    public int getBit(int bitStorage, int bitIndex) // получить значение бита по определенному индексу
    {
        int res = bitStorage & (1<<bitIndex);
        return (res > 0) ? 1 : 0;
    }
}

/*СУТЬ ФИЛЬТРА БЛЮМА
 * Т.е. нам надо быстро проверить - есть ли элемент в множестве. Для этого элемент загоняется в фильтр Блюма,
 * который из себя представляет битовый массив. В самом простом варианте в качестве битового массива выступает
 * 32-разрядное число - простой int. Т.е. берем число 0 типа int и рассматриваем его как массив битов из 32 элементов
 * Для того, чтобы поместить элемент в фильтр, нам надо рассчитать число хэш-функций в зависимости от длины элемента.
 * Например у нас строка из 10 символов, значит число элементов равно 10. И для массива в 32 символа и 10 эл-тов
 * будет достаточно 2-х хэш-функций.
 *
 * Хэш-функциями вычисляем 2 индекса. В эти индексы в битовом массиве устанавливаем 1. И у нас получается
 * битовая маска для нашего значения по сути. Т.е. массив битов, где проставлены 1 только в нужные индексы, остальное нули.
 *
 * И для того, чтобы проверить, входит ли элемент во множество, надо для этого элемента (например для строки)
 * теми же хэш-функциями посчитать индексы. И проверить значения в полученных индексах. Если во всех индексах будет 1,
 * то значит элемент принадлежит множеству. Если хотя бы в одном единицы не будет, значит не принадлежит.
 * */