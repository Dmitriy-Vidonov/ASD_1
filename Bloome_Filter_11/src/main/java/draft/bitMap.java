package draft;

public class bitMap { // Разбор битовой карты - что это такое
    // https://javarush.com/quests/lectures/questmultithreading.level10.lecture10  - неплохой урок по теме битовой карты
    public static void main(String[] args)
    {
        // Пример хранения логических значений в одном числе
        boolean a = true;
        boolean b = false;
        boolean c = true;
        boolean d = false;

        // Упаковка их в одно число
        int result = 0;
        if(a) result += 1; // 1 == 2^0 - нулевой бит
        if(b) result += 2; // 2 == 2^1 - первый бит
        if(c) result += 4; // 4 == 2^2 - второй бит
        if(d) result += 8; // 8 == 2^3 - третий бит

        // У каждого бита - своя переменная. И если логическая переменная = true, то значит бит = 1
        // 0000 0101 =
        // 0000 dcba
        // a = true, c = true, значит result = 1 + 4 = 5
        System.out.println("result = " + result); // == 5.

        // Например надо узнать, установлен ли 5-й бит числа в 1 или нет. 2^5 = 32. Как это можно проверить
        // Соединяем числа в одно
        int a1 = 32; // 2^5 == 0010 0000 - 5-й бит установлен в единицу. Это 1 на 5-ой позиции. 2^5 = 32
        int b1 = 8; // 2^3 == 0000 1000 - 3-й бит установлен в единицу. Это 1 на 3-й позиции. 2^3 = 8
        int c1 = 2; // 2^1 == 0000 0010 - 1-й бит установлен в единицу. Это 1 на 1-й позиции. 2^1 = 2

        result = a1 + b1 + c1; // 32 + 8 + 2 == 42 == 0010 1010
        System.out.println("result2 = " + result);

        int res = result & 00100000;
        System.out.println("бит - " + res); // не понятно, почему дает 0, а не 1

        // Теперь сделаем обратное - проверяем, установлен ли определенный бит
        int a2 = result & 32; // 0010 1010 & 0010 0000 = 0010 0000 (логическое И - 1 и 1 = 1, 1 и 0 = 0, 0 и 0 = 0)
        int b2 = result & 8; // 0010 1010 & 0000 1000 = 0000 1000
        int c2 = result & 2; // 0010 1010 & 0000 0010 = 0000 0010

        System.out.println("a2 = " + a2 + ", b2 = " + b2 + ", c2 = " + c2); // a2 = 32, b2 = 8, c2 = 2

        // По сути для работы с битовыми масками нужны три операции:
        // 1) Установить определенный бит в 0
        // 2) Установить определенный бит в 1
        // 3) Проверить, какое значение определенного бита

        // Теперь реализуем эти операции на практике
        // Например, у нас есть бит номер 6

        // Как установить в единицу бит номер 6?
        // result == 42 == 0010 1010

        //result = result | 0100 0000;
        result |= 0100_0000; // Логическое ИЛИ - если были единицы - они у нас останутся единицами, а было 0, станет 1

        System.out.println("result |= " + result); // 262186.  0010 1010 | 0100 0000 == 0110 1010

        // Как установить в ноль бит номер 6?
        result &= 1011_1111;

        System.out.println("result &= " + result); // 2. 0110 1010 & 1011 1111 == 0000 0000 ?

        // Как получить значение 6-ого бита
        int c3 = result & 0000_0001;

        System.out.println("c3 = " + c3); // 0

        // Как легко получить числа со снятым или установленным определенным битом? 0100_0000 или 1011_1111
        // Для этого есть операция сдвига >> и <<

        // 1 - это 2 в 0-й степени. Т.е. число с установленным нулевым битом. Мы хотим число с установленным 6-м битом:
        int c4 = 1<<6; // 0000 0001 << 6 == 0010 0000 == 64  (т.е. мы взяли 2^0, что равно 1, сделалм 2^6, что равно 64

        // Что делать, если нужно наоборот - число, где все биты 1, а один определенный - 0?
        int d1 = ~(1<<6); // ~0100 0000 == 1011 1111 = -65. Т.е. мы сначала сделали 1<<6, а потом обратили символы через ~
        System.out.println("d1 = " + d1);

        // Как установить в 1 6-й бит?
        //result = result | (1<<6);
        result |= (1<<6);

        // Как установить в 0 бит 6?
        // result = result & ~(1<<6);
        result &= ~(1<<6);

        // Как получить значение 6-ого бита?
        int c5 = result & (1<<6);

        // ОПЕРАЦИИ ПОБИТОВОГО СДВИГА
        // https://javarush.com/quests/lectures/questsyntaxpro.level08.lecture05

        // Установить флаг = сделать определенный бит равным 1.
        // Это побитовое ИЛИ между исходным числом и числом, у которого только этот нужный бит равен 1
        // Например, вам нужно в числе 0b00001010 установить 5-й бит в 1, тогда нужно сделать так:
        // 0b00001010 | 0b00010000 = 0b00011010
        // В общем виде операцию установки флага можно записать так
        // a | (1 << b), где а - исходное число, b - индекс устанавливаемого бита


        // Сбросить флаг = сделать определенный бит равным 0
        // Это побитовое И между исходным числом и числом, где все биты кроме исходного равны 1
        // Например, вам нужно в числе 0b00001010 установить 4-й бит в 0, тогда нужно сделать так:
        // 0b00001010 & 0b11110111 = 0b00000010
        // В общем виде операцию сброса флага можно записать так
        // a & ~(1 << b), где а - исходное число, b - индекс сбрасываемого бита, ~ - побитовое НЕ


        // Проверить флаг = проверить, чему равен определенный бит.
        // Например, вам нужно в числе 0b00001010 проверить, установлен ли 4-й бит в 1. Тогда нужно сделать так:
        // if ( (0b00001010 & 0b00001000) == 0b00001000 ) - то есть проверяем, если операция корректна, то 4-й бит в 1
        // В общем виде операцию проверки флага можно записать так:
        // (a & (1 << b)) == (1 << b), где a — это проверяемое число, b — это индекс проверяемого бита

        // XOR - исключающее ИЛИ

    }
}
