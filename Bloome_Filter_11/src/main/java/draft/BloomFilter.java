package draft;

public class BloomFilter {
    public int filter_len; // для примера берем длину фильтра m = 32
    public int bitStorage; // зададим битовый массив - хранилище битов - он же число int. Это будет 0,
                            // т.к. все биты уже в 0 установлены
    public int index1; // индекс, получаемый от 1-й хэш-функции
    public int index2; // индекс, получаемый от 2-й хэш-функции

    public BloomFilter(int f_len) // конструктор класса, в который передаем длину фильтра, которая задается при
    {                             // создании нового экземпляра класса
        filter_len = f_len; // для примера возьмем f_len = 32 (целое число int) и цикл по всем разрядам - от до 0 до 31
        // создаём битовый массив длиной f_len, т.е. битовый массив у нас это число
        bitStorage = 0; // int-овый ноль - у нас являет собой массив из 32 битов. И изначально все в нуле установлены.
    }

    // хэш-функции
    public int hash1(String str1)
    {
        int res = 0;
        int rand = 17;
        int len = str1.length();
        // 17
        for(int i=0; i<len; i++)
        {
            if (i == 0) continue;
            int code = (int)str1.charAt(i);
            res += (res * rand) + code;
        }
        int index = res % len;
        return index;
    }
    public int hash2(String str1)
    {
        int res = 0;
        int rand = 223;
        int len = str1.length();
        // 223
        for(int i=0; i<len; i++)
        {
            if (i == 0) continue;
            int code = (int)str1.charAt(i);
            res += (res * rand) + code;
        }
        int index = res % len;
        return index;
    }

    public void add(String str1)
    {
        // добавляем строку str1 в фильтр
        // добавить строку в фильтр - значит рассчитать хэш-функциями индексы для этой строки и проставить
        // в битовом массиве в полученные индексы - единицы
        // перед добавлением новой строки нам требуется обнулить все элементы в битовом массиве, т.е. обнулить bitStorage
        // плюс обнулить оба индекса
        bitStorage = 0;
        index1 = 0;
        index2 = 0;
        // Затем посчитать индексы через хэш-функции
        index1 = this.hash1(str1); // получили индекс от 1-й хэш-функции
        index2 = this.hash2(str1); // получили индекс от 2-й хэш-функции

        // затем нам надо в bitStorage проставить 1 в полученные индексы
        bitStorage = this.setBit(bitStorage, index1);
        bitStorage = this.setBit(bitStorage, index2);
    }

    public boolean isValue(String str1)
    {
        // проверка, имеется ли строка str1 в фильтре
        // мы берем строку, считаем для нее индексы хэш-функциями и проверяем значения в индексах внутри bitStorage
        int index1 = hash1(str1);
        int index2 = hash2(str1);
        // если в обеих полученных индексах лежат 1, то true, иначе false
        return (getBit(this.bitStorage, index1) == 1 && getBit(this.bitStorage, index2) == 1);
    }

    // установить бит 1 в нужную позицию (по индексу)
    public int setBit(int bitStorage, int bitIndex)
    {
        int res = bitStorage;
        res |= (1<<bitIndex);
        return res;
    }

    // снятие бита в нужной позиции (по индексу)
    public int removeBit(int bitStorage, int bitIndex)
    {
        int res = bitStorage;
        res &= ~(1<<bitIndex);
        return res;
    }

    // получить значение бита в нужной позиции (по индексу)
    public int getBit(int bitStorage, int bitIndex)
    {
        int res = bitStorage & (1<<bitIndex);
        return (res > 0) ? 1 : 0;
    }
}

/*СУТЬ ФИЛЬТРА БЛЮМА
* Т.е. нам надо быстро проверить - есть ли элемент в множестве. Для этого элемент загоняется в фильтр Блюма,
* который из себя представляет битовый массив. В самом простом варианте в качестве битового массива выступает
* 32-разрядное число - простой int. Т.е. берем число 0 типа int и рассматриваем его как массив битов из 32 элементов
* Для того, чтобы поместить элемент в фильтр, нам надо рассчитать число хэш-функций в зависимости от длины элемента.
* Например у нас строка из 10 символов, значит число элементов равно 10. И для массива в 32 символа и 10 эл-тов
* будет достаточно 2-х хэш-функций.
*
* Хэш-функциями вычисляем 2 индекса. В эти индексы в битовом массиве устанавливаем 1. И у нас получается
* битовая маска для нашего значения по сути. Т.е. массив битов, где проставлены 1 только в нужные индексы, остальное нули.
*
* И для того, чтобы проверить, входит ли элемент во множество, надо для этого элемента (например для строки)
* теми же хэш-функциями посчитать индексы. И проверить значения в полученных индексах. Если во всех индексах будет 1,
* то значит элемент принадлежит множеству. Если хотя бы в одном единицы не будет, значит не принадлежит.
* */